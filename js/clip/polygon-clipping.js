(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["polygon-clipping"] = factory();
	else
		root["polygon-clipping"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/splaytree/index.js":
/*!*****************************************!*\
  !*** ./node_modules/splaytree/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * @typedef {function(node:Node):void} Visitor\n */\n\n/**\n * @typedef {function(a:Key, b:Key):number} Comparator\n */\n\n/**\n * @param {function(node:Node):string} NodePrinter\n */\n\n/**\n * @typedef {Object}  Node\n * @property {Key}    Key\n * @property {Value=} data\n * @property {Node}   left\n * @property {Node}   right\n */\n\nvar Node = function Node(key, data) {\n  _classCallCheck(this, Node);\n\n  this.key = key;\n  this.data = data;\n  this.left = null;\n  this.right = null;\n};\n\nfunction DEFAULT_COMPARE(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n * @param {Key} i\n * @param {Node?} t\n * @param {Comparator} comparator\n */\nfunction splay(i, t, comparator) {\n  if (t === null) return t;\n  var l = void 0,\n      r = void 0,\n      y = void 0;\n  var N = new Node();\n  l = r = N;\n\n  while (true) {\n    var cmp = comparator(i, t.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        y = t.left; /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t; /* link right */\n      r = t;\n      t = t.left;\n      //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        y = t.right; /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t; /* link left */\n      l = t;\n      t = t.right;\n    } else {\n      break;\n    }\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\n/**\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}      root\n */\nfunction _insert(i, data, t, comparator, tree) {\n  var node = new Node(i, data);\n\n  tree._size++;\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\n/**\n * Insert i into the tree t, unless it's already there.\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}       root\n */\nfunction _add(i, data, t, comparator, tree) {\n  var node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    tree._size++;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) return t;else {\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp > 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    tree._size++;\n    return node;\n  }\n}\n\n/**\n * Deletes i from the tree if it's there\n * @param {Key}        i\n * @param {Tree}       tree\n * @param {Comparator} comparator\n * @param {Tree}       tree\n * @return {Node}      new root\n */\nfunction _remove(i, t, comparator, tree) {\n  var x = void 0;\n  if (t === null) return null;\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) {\n    /* found it */\n    if (t.left === null) {\n      x = t.right;\n    } else {\n      x = splay(i, t.left, comparator);\n      x.right = t.right;\n    }\n    tree._size--;\n    return x;\n  }\n  return t; /* It wasn't there */\n}\n\nfunction _split(key, v, comparator) {\n  var left = void 0,\n      right = void 0;\n  if (v === null) {\n    left = right = null;\n  } else {\n    v = splay(key, v, comparator);\n\n    var cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right = v.right;\n      v.right = null;\n      left = v;\n    } else {\n      left = v.left;\n      v.left = null;\n      right = v;\n    }\n  }\n  return { left: left, right: right };\n}\n\nfunction merge(left, right, comparator) {\n  if (right === null) return left;\n  if (left === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Array<string>}               out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction printRow(root, prefix, isTail, out, printNode) {\n  if (root) {\n    out('' + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + '\\n');\n    var indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left) printRow(root.left, indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true, out, printNode);\n  }\n}\n\nvar Tree = function () {\n  function Tree() {\n    var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_COMPARE;\n\n    _classCallCheck(this, Tree);\n\n    this._comparator = comparator;\n    this._root = null;\n    this._size = 0;\n  }\n\n  /**\n   * Inserts a key, allows duplicates\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n\n\n  _createClass(Tree, [{\n    key: 'insert',\n    value: function insert(key, data) {\n      return this._root = _insert(key, data, this._root, this._comparator, this);\n    }\n\n    /**\n     * Adds a key, if it is not present in the tree\n     * @param  {Key}    key\n     * @param  {Value=} data\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'add',\n    value: function add(key, data) {\n      return this._root = _add(key, data, this._root, this._comparator, this);\n    }\n\n    /**\n     * @param  {Key} key\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(key) {\n      this._root = _remove(key, this._root, this._comparator, this);\n    }\n\n    /**\n     * Removes and returns the node with smallest key\n     * @return {?Node}\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      var node = this._root;\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }this._root = splay(node.key, this._root, this._comparator);\n        this._root = _remove(node.key, this._root, this._comparator, this);\n        return { key: node.key, data: node.data };\n      }\n      return null;\n    }\n\n    /**\n     * @param  {Key} key\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'findStatic',\n    value: function findStatic(key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return null;\n    }\n\n    /**\n     * @param  {Key} key\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'find',\n    value: function find(key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n      return this._root;\n    }\n\n    /**\n     * @param  {Key} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return false;\n    }\n\n    /**\n     * @param  {Visitor} visitor\n     * @param  {*=}      ctx\n     * @return {SplayTree}\n     */\n\n  }, {\n    key: 'forEach',\n    value: function forEach(visitor, ctx) {\n      var current = this._root;\n      var Q = []; /* Initialize stack s */\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n     * @param  {Key}      low\n     * @param  {Key}      high\n     * @param  {Function} fn\n     * @param  {*?}       ctx\n     * @return {SplayTree}\n     */\n\n  }, {\n    key: 'range',\n    value: function range(low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root,\n          cmp = void 0;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n          node = node.right;\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Returns array of keys\n     * @return {Array<Key>}\n     */\n\n  }, {\n    key: 'keys',\n    value: function keys() {\n      var keys = [];\n      this.forEach(function (_ref) {\n        var key = _ref.key;\n        return keys.push(key);\n      });\n      return keys;\n    }\n\n    /**\n     * Returns array of all the data in the nodes\n     * @return {Array<Value>}\n     */\n\n  }, {\n    key: 'values',\n    value: function values() {\n      var values = [];\n      this.forEach(function (_ref2) {\n        var data = _ref2.data;\n        return values.push(data);\n      });\n      return values;\n    }\n\n    /**\n     * @return {Key|null}\n     */\n\n  }, {\n    key: 'min',\n    value: function min() {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    }\n\n    /**\n     * @return {Key|null}\n     */\n\n  }, {\n    key: 'max',\n    value: function max() {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    }\n\n    /**\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'minNode',\n    value: function minNode() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._root;\n\n      if (t) while (t.left) {\n        t = t.left;\n      }return t;\n    }\n\n    /**\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'maxNode',\n    value: function maxNode() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._root;\n\n      if (t) while (t.right) {\n        t = t.right;\n      }return t;\n    }\n\n    /**\n     * Returns node at given index\n     * @param  {number} index\n     * @return {?Node}\n     */\n\n  }, {\n    key: 'at',\n    value: function at(index) {\n      var current = this._root,\n          done = false,\n          i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @param  {Node}   d\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'next',\n    value: function next(d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n        while (successor.left) {\n          successor = successor.left;\n        }return successor;\n      }\n\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    }\n\n    /**\n     * @param  {Node} d\n     * @return {Node|null}\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev(d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }return predecessor;\n      }\n\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n      return predecessor;\n    }\n\n    /**\n     * @return {SplayTree}\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._root = null;\n      this._size = 0;\n      return this;\n    }\n\n    /**\n     * @return {NodeList}\n     */\n\n  }, {\n    key: 'toList',\n    value: function toList() {\n      return _toList(this._root);\n    }\n\n    /**\n     * Bulk-load items. Both array have to be same size\n     * @param  {Array<Key>}    keys\n     * @param  {Array<Value>}  [values]\n     * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n     *                                         tree's comparator. Sorting is done\n     *                                         in-place\n     * @return {AVLTree}\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var presort = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var size = keys.length;\n      var comparator = this._comparator;\n\n      // sort if needed\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(this._root, keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({ head: mergedList }, 0, size);\n      }\n      return this;\n    }\n\n    /**\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      return this._root === null;\n    }\n  }, {\n    key: 'toString',\n\n\n    /**\n     * @param  {NodePrinter=} printNode\n     * @return {String}\n     */\n    value: function toString() {\n      var printNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (n) {\n        return n.key;\n      };\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    }\n  }, {\n    key: 'update',\n    value: function update(key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _split2 = _split(key, this._root, comparator),\n          left = _split2.left,\n          right = _split2.right;\n\n      this._size--;\n      if (comparator(key, newKey) < 0) {\n        right = _insert(newKey, newData, right, comparator, this);\n      } else {\n        left = _insert(newKey, newData, left, comparator, this);\n      }\n      this._root = merge(left, right, comparator);\n    }\n  }, {\n    key: 'split',\n    value: function split(key) {\n      return _split(key, this._root, this._comparator);\n    }\n  }, {\n    key: 'size',\n    get: function get() {\n      return this._size;\n    }\n  }]);\n\n  return Tree;\n}();\n\nexports.default = Tree;\n\n\nfunction loadRecursive(parent, keys, values, start, end) {\n  var size = end - start;\n  if (size > 0) {\n    var middle = start + Math.floor(size / 2);\n    var key = keys[middle];\n    var data = values[middle];\n    var node = { key: key, data: data, parent: parent };\n    node.left = loadRecursive(node, keys, values, start, middle);\n    node.right = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\nfunction createList(keys, values) {\n  var head = { next: null };\n  var p = head;\n  for (var i = 0; i < keys.length; i++) {\n    p = p.next = { key: keys[i], data: values[i] };\n  }\n  p.next = null;\n  return head.next;\n}\n\nfunction _toList(root) {\n  var current = root;\n  var Q = [],\n      done = false;\n\n  var head = { next: null };\n  var p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop();\n        current = current.right;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next;\n}\n\nfunction sortedListToBST(list, start, end) {\n  var size = end - start;\n  if (size > 0) {\n    var middle = start + Math.floor(size / 2);\n    var left = sortedListToBST(list, start, middle);\n\n    var root = list.head;\n    root.left = left;\n\n    list.head = list.head.next;\n\n    root.right = sortedListToBST(list, middle + 1, end);\n    return root;\n  }\n  return null;\n}\n\nfunction mergeLists(l1, l2) {\n  var compare = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (a, b) {\n    return a - b;\n  };\n\n  var head = {}; // dummy\n  var p = head;\n\n  var p1 = l1;\n  var p2 = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next;\n    } else {\n      p.next = p2;\n      p2 = p2.next;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null) p.next = p1;else if (p2 !== null) p.next = p2;\n\n  return head.next;\n}\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  var pivot = keys[left + right >> 1];\n  var i = left - 1;\n  var j = right + 1;\n\n  while (true) {\n    do {\n      i++;\n    } while (compare(keys[i], pivot) < 0);\n    do {\n      j--;\n    } while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    var tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values, left, j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://polygon-clipping/./node_modules/splaytree/index.js?");

/***/ }),

/***/ "./src/bbox.js":
/*!*********************!*\
  !*** ./src/bbox.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUniqueCorners = exports.getBboxOverlap = exports.doBboxesOverlap = exports.isInBbox = undefined;\n\nvar _flp = __webpack_require__(/*! ./flp */ \"./src/flp.js\");\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nvar isInBbox = exports.isInBbox = function isInBbox(bbox, point) {\n  var xmin = bbox.ll.x;\n  var ymin = bbox.ll.y;\n  var xmax = bbox.ur.x;\n  var ymax = bbox.ur.y;\n  var xpt = point.x;\n  var ypt = point.y;\n  return (0, _flp.cmp)(xmin, xpt) <= 0 && (0, _flp.cmp)(xpt, xmax) <= 0 && (0, _flp.cmp)(ymin, ypt) <= 0 && (0, _flp.cmp)(ypt, ymax) <= 0;\n};\n\nvar doBboxesOverlap = exports.doBboxesOverlap = function doBboxesOverlap(b1, b2) {\n  return !((0, _flp.cmp)(b2.ur.x, b1.ll.x) < 0 || (0, _flp.cmp)(b1.ur.x, b2.ll.x) < 0 || (0, _flp.cmp)(b2.ur.y, b1.ll.y) < 0 || (0, _flp.cmp)(b1.ur.y, b2.ll.y) < 0);\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nvar getBboxOverlap = exports.getBboxOverlap = function getBboxOverlap(b1, b2) {\n  if (!doBboxesOverlap(b1, b2)) return null;\n\n  // find the middle two X values\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\n};\n\n/* Returns a list of unique corners.\n * Will contain one, two or four points */\nvar getUniqueCorners = exports.getUniqueCorners = function getUniqueCorners(bbox) {\n  var xmin = bbox.ll.x;\n  var ymin = bbox.ll.y;\n  var xmax = bbox.ur.x;\n  var ymax = bbox.ur.y;\n  var xEq = (0, _flp.cmp)(xmin, xmax) === 0;\n  var yEq = (0, _flp.cmp)(ymin, ymax) === 0;\n  if (!xEq && !yEq) {\n    return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }, { x: xmax, y: ymin }, { x: xmax, y: ymax }];\n  }\n  if (xEq && !yEq) return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }];\n  if (!xEq && yEq) return [{ x: xmin, y: ymin }, { x: xmax, y: ymin }];\n  return [{ x: xmin, y: ymin }];\n};\n\n//# sourceURL=webpack://polygon-clipping/./src/bbox.js?");

/***/ }),

/***/ "./src/clean-input.js":
/*!****************************!*\
  !*** ./src/clean-input.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanRing = exports.cleanMultiPoly = exports.forceMultiPoly = exports.pointsAsObjects = undefined;\n\nvar _flp = __webpack_require__(/*! ./flp */ \"./src/flp.js\");\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\n/* Given input geometry as a standard array-of-arrays geojson-style\n * geometry, return one that uses objects as points, for better perf */\nvar pointsAsObjects = exports.pointsAsObjects = function pointsAsObjects(geom) {\n  // we can handle well-formed multipolys and polys\n  var output = [];\n  if (!Array.isArray(geom)) {\n    throw new Error('Input is not a Polygon or MultiPolygon');\n  }\n  for (var i = 0, iMax = geom.length; i < iMax; i++) {\n    if (!Array.isArray(geom[i]) || geom[i].length == 0) {\n      throw new Error('Input is not a Polygon or MultiPolygon');\n    }\n    output.push([]);\n    for (var j = 0, jMax = geom[i].length; j < jMax; j++) {\n      if (!Array.isArray(geom[i][j]) || geom[i][j].length == 0) {\n        throw new Error('Input is not a Polygon or MultiPolygon');\n      }\n      if (Array.isArray(geom[i][j][0])) {\n        // multipolygon\n        output[i].push([]);\n        for (var k = 0, kMax = geom[i][j].length; k < kMax; k++) {\n          if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length < 2) {\n            throw new Error('Input is not a Polygon or MultiPolygon');\n          }\n          if (geom[i][j][k].length > 2) {\n            throw new Error('Input has more than two coordinates. ' + 'Only 2-dimensional polygons supported.');\n          }\n          output[i][j].push({ x: geom[i][j][k][0], y: geom[i][j][k][1] });\n        }\n      } else {\n        // polygon\n        if (geom[i][j].length < 2) {\n          throw new Error('Input is not a Polygon or MultiPolygon');\n        }\n        if (geom[i][j].length > 2) {\n          throw new Error('Input has more than two coordinates. ' + 'Only 2-dimensional polygons supported.');\n        }\n        output[i].push({ x: geom[i][j][0], y: geom[i][j][1] });\n      }\n    }\n  }\n  return output;\n};\n\n/* WARN: input modified directly */\nvar forceMultiPoly = exports.forceMultiPoly = function forceMultiPoly(geom) {\n  if (Array.isArray(geom)) {\n    if (geom.length === 0) return; // allow empty multipolys\n\n    if (Array.isArray(geom[0])) {\n      if (Array.isArray(geom[0][0])) {\n        if (typeof geom[0][0][0].x === 'number' && typeof geom[0][0][0].y === 'number') {\n          // multipolygon\n          return;\n        }\n      }\n      if (typeof geom[0][0].x === 'number' && typeof geom[0][0].y === 'number') {\n        // polygon\n        geom.unshift(geom.splice(0));\n        return;\n      }\n    }\n  }\n  throw new Error('Unrecognized input - not a polygon nor multipolygon');\n};\n\n/* WARN: input modified directly */\nvar cleanMultiPoly = exports.cleanMultiPoly = function cleanMultiPoly(multipoly) {\n  var i = 0;\n  while (i < multipoly.length) {\n    var poly = multipoly[i];\n    if (poly.length === 0) {\n      multipoly.splice(i, 1);\n      continue;\n    }\n\n    var exteriorRing = poly[0];\n    cleanRing(exteriorRing);\n    // poly is dropped if exteriorRing is degenerate\n    if (exteriorRing.length === 0) {\n      multipoly.splice(i, 1);\n      continue;\n    }\n\n    var j = 1;\n    while (j < poly.length) {\n      var interiorRing = poly[j];\n      cleanRing(interiorRing);\n      if (interiorRing.length === 0) poly.splice(j, 1);else j++;\n    }\n\n    i++;\n  }\n};\n\n/* Clean ring:\n *  - remove duplicate points\n *  - remove colinear points\n *  - remove rings with no area (less than 3 distinct points)\n *  - un-close rings (last point should not repeat first)\n *\n * WARN: input modified directly */\nvar cleanRing = exports.cleanRing = function cleanRing(ring) {\n  if (ring.length === 0) return;\n  if ((0, _flp.cmpPoints)(ring[0], ring[ring.length - 1]) === 0) ring.pop();\n\n  var isPointUncessary = function isPointUncessary(prevPt, pt, nextPt) {\n    return (0, _flp.cmpPoints)(prevPt, pt) === 0 || (0, _flp.cmpPoints)(pt, nextPt) === 0 || (0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0;\n  };\n\n  var i = 0;\n  var prevPt = void 0,\n      nextPt = void 0;\n  while (i < ring.length) {\n    prevPt = i === 0 ? ring[ring.length - 1] : ring[i - 1];\n    nextPt = i === ring.length - 1 ? ring[0] : ring[i + 1];\n    if (isPointUncessary(prevPt, ring[i], nextPt)) ring.splice(i, 1);else i++;\n  }\n\n  // if our ring has less than 3 distinct points now (so is degenerate)\n  // shrink it down to the empty array to communicate to our caller to\n  // drop it\n  while (ring.length < 3 && ring.length > 0) {\n    ring.pop();\n  }\n};\n\n//# sourceURL=webpack://polygon-clipping/./src/clean-input.js?");

/***/ }),

/***/ "./src/flp.js":
/*!********************!*\
  !*** ./src/flp.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nvar epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\n\nvar EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nvar cmp = exports.cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  if ((a - b) * (a - b) < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/* FLP point comparator, favors point encountered first by sweep line */\nvar cmpPoints = exports.cmpPoints = function cmpPoints(aPt, bPt) {\n  if (aPt === bPt) return 0;\n\n  // fist compare X, then compare Y\n  var a = aPt.x;\n  var b = bPt.x;\n\n  // inlined version of cmp() for performance boost\n  if (a <= -epsilon || epsilon <= a || b <= -epsilon || epsilon <= b) {\n    var diff = a - b;\n    if (diff * diff >= EPSILON_SQ * a * b) {\n      return a < b ? -1 : 1;\n    }\n  }\n\n  a = aPt.y;\n  b = bPt.y;\n\n  // inlined version of cmp() for performance boost\n  if (a <= -epsilon || epsilon <= a || b <= -epsilon || epsilon <= b) {\n    var _diff = a - b;\n    if (_diff * _diff >= EPSILON_SQ * a * b) {\n      return a < b ? -1 : 1;\n    }\n  }\n\n  // they're the same\n  return 0;\n};\n\n//# sourceURL=webpack://polygon-clipping/./src/flp.js?");

/***/ }),

/***/ "./src/geom-in.js":
/*!************************!*\
  !*** ./src/geom-in.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiPolyIn = exports.PolyIn = exports.RingIn = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _segment = __webpack_require__(/*! ./segment */ \"./src/segment.js\");\n\nvar _segment2 = _interopRequireDefault(_segment);\n\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \"./src/sweep-event.js\");\n\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RingIn = exports.RingIn = function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    var prevPoint = geomRing[0];\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      var point = geomRing[i];\n      this.segments.push(_segment2.default.fromRing(prevPoint, point, this));\n      prevPoint = point;\n    }\n    this.segments.push(_segment2.default.fromRing(prevPoint, geomRing[0], this));\n  }\n\n  _createClass(RingIn, [{\n    key: 'getSweepEvents',\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\n\nvar PolyIn = exports.PolyIn = function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    this.interiorRings = [];\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      this.interiorRings.push(new RingIn(geomPoly[i], this, false));\n    }\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: 'getSweepEvents',\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\n\nvar MultiPolyIn = exports.MultiPolyIn = function () {\n  function MultiPolyIn(geomMultiPoly) {\n    _classCallCheck(this, MultiPolyIn);\n\n    this.polys = [];\n    for (var i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\n      this.polys.push(new PolyIn(geomMultiPoly[i], this));\n    }\n    this.isSubject = false;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: 'markAsSubject',\n    value: function markAsSubject() {\n      this.isSubject = true;\n    }\n  }, {\n    key: 'getSweepEvents',\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\n//# sourceURL=webpack://polygon-clipping/./src/geom-in.js?");

/***/ }),

/***/ "./src/geom-out.js":
/*!*************************!*\
  !*** ./src/geom-out.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiPolyOut = exports.PolyOut = exports.RingOut = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \"./src/sweep-event.js\");\n\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RingOut = exports.RingOut = function () {\n  _createClass(RingOut, null, [{\n    key: 'factory',\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n\n        /* Walk the chain of linked events to form a closed ring */\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n\n          /* Is the ring complete? */\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error('Unable to complete output ring starting at [' + firstPt.x + ',' + (' ' + firstPt.y + ']. Last matching segment found ends at') + (' [' + lastPt.x + ', ' + lastPt.y + '].'));\n            }\n\n            /* Only one way to go, so cotinue on the path */\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n\n            /* We must have an intersection. Check for a completed loop */\n            var indexLE = null;\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: 'getGeom',\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if ((0, _vector.compareVectorAngles)(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      }\n\n      // ring was all (within rounding error of angle calc) colinear points\n      if (points.length === 1) return null;\n\n      // check if the starting point is necessary\n      var pt = points[0];\n      var nextPt = points[1];\n      if ((0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0) points.shift();\n\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }return orderedPoints;\n    }\n  }, {\n    key: 'isExteriorRing',\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n      return this._isExteriorRing;\n    }\n  }, {\n    key: 'enclosingRing',\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n      return this._enclosingRing;\n    }\n\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: '_calcEnclosingRing',\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (_sweepEvent2.default.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null;\n\n        // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n        if (!prevPrevSeg) return prevSeg.ringOut;\n\n        // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        }\n\n        // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\n\nvar PolyOut = exports.PolyOut = function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: 'addInterior',\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: 'getGeom',\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()];\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (geom[0] === null) return null;\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom();\n        // interior ring was all (within rounding error of angle calc) colinear points\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\n\nvar MultiPolyOut = exports.MultiPolyOut = function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: 'getGeom',\n    value: function getGeom() {\n      var geom = [];\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom();\n        // exterior ring was all (within rounding error of angle calc) colinear points\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n      return geom;\n    }\n  }, {\n    key: '_composePolys',\n    value: function _composePolys(rings) {\n      var polys = [];\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n//# sourceURL=webpack://polygon-clipping/./src/geom-out.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _operation = __webpack_require__(/*! ./operation */ \"./src/operation.js\");\n\nvar _operation2 = _interopRequireDefault(_operation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return _operation2.default.run('union', geom, moreGeoms);\n};\n\nvar intersection = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return _operation2.default.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return _operation2.default.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return _operation2.default.run('difference', subjectGeom, clippingGeoms);\n};\n\nexports.default = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://polygon-clipping/./src/index.js?");

/***/ }),

/***/ "./src/operation.js":
/*!**************************!*\
  !*** ./src/operation.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Operation = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _splaytree = __webpack_require__(/*! splaytree */ \"./node_modules/splaytree/index.js\");\n\nvar _splaytree2 = _interopRequireDefault(_splaytree);\n\nvar _cleanInput = __webpack_require__(/*! ./clean-input */ \"./src/clean-input.js\");\n\nvar cleanInput = _interopRequireWildcard(_cleanInput);\n\nvar _geomIn = __webpack_require__(/*! ./geom-in */ \"./src/geom-in.js\");\n\nvar geomIn = _interopRequireWildcard(_geomIn);\n\nvar _geomOut = __webpack_require__(/*! ./geom-out */ \"./src/geom-out.js\");\n\nvar geomOut = _interopRequireWildcard(_geomOut);\n\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \"./src/sweep-event.js\");\n\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\n\nvar _sweepLine = __webpack_require__(/*! ./sweep-line */ \"./src/sweep-line.js\");\n\nvar _sweepLine2 = _interopRequireDefault(_sweepLine);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Operation = exports.Operation = function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: 'run',\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n\n      /* Make a copy of the input geometry with points as objects, for perf */\n      var geoms = [cleanInput.pointsAsObjects(geom)];\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]));\n      }\n\n      /* Clean inputs */\n      for (var _i = 0, _iMax = geoms.length; _i < _iMax; _i++) {\n        cleanInput.forceMultiPoly(geoms[_i]);\n        cleanInput.cleanMultiPoly(geoms[_i]);\n      }\n\n      /* Convert inputs to MultiPoly objects, mark subject */\n      var multipolys = [];\n      for (var _i2 = 0, _iMax2 = geoms.length; _i2 < _iMax2; _i2++) {\n        multipolys.push(new geomIn.MultiPolyIn(geoms[_i2]));\n      }\n      multipolys[0].markAsSubject();\n      operation.numMultiPolys = multipolys.length;\n\n      /* Put segment endpoints in a priority queue */\n      var queue = new _splaytree2.default(_sweepEvent2.default.compare);\n      for (var _i3 = 0, _iMax3 = multipolys.length; _i3 < _iMax3; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n        for (var j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n          queue.insert(sweepEvents[j]);\n        }\n      }\n\n      /* Pass the sweep line over those endpoints */\n      var sweepLine = new _sweepLine2.default(queue);\n      var node = void 0;\n      var prevQueueSize = queue.size;\n      while (node = queue.pop()) {\n        var evt = node.key;\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Unable to pop() SweepEvent #' + evt.id + ' [' + evt.point.x + ', ' + evt.point.y + '] ' + 'from queue. Please file a bug report.');\n        }\n        var newEvents = sweepLine.process(evt);\n        for (var _i4 = 0, _iMax4 = newEvents.length; _i4 < _iMax4; _i4++) {\n          queue.insert(newEvents[_i4]);\n        }\n        prevQueueSize = queue.size;\n      }\n\n      /* Collect and compile segments we're keeping into a multipolygon */\n      var ringsOut = geomOut.RingOut.factory(sweepLine.segments);\n      var result = new geomOut.MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}();\n\n// singleton available by import\n\n\nvar operation = new Operation();\n\nexports.default = operation;\n\n//# sourceURL=webpack://polygon-clipping/./src/operation.js?");

/***/ }),

/***/ "./src/segment.js":
/*!************************!*\
  !*** ./src/segment.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _operation = __webpack_require__(/*! ./operation */ \"./src/operation.js\");\n\nvar _operation2 = _interopRequireDefault(_operation);\n\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \"./src/sweep-event.js\");\n\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\n\nvar _bbox = __webpack_require__(/*! ./bbox */ \"./src/bbox.js\");\n\nvar _flp = __webpack_require__(/*! ./flp */ \"./src/flp.js\");\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Segment = function () {\n  _createClass(Segment, null, [{\n    key: 'compare',\n    value: function compare(a, b) {\n\n      var alx = a.leftSE.point.x;\n      var aly = a.leftSE.point.y;\n      var blx = b.leftSE.point.x;\n      var bly = b.leftSE.point.y;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x;\n\n      // check if they're even in the same vertical plane\n      if ((0, _flp.cmp)(brx, alx) < 0) return 1;\n      if ((0, _flp.cmp)(arx, blx) < 0) return -1;\n\n      // check for a consumption relationship. if present,\n      // avoid the segment angle calculations (can yield\n      // inconsistent results after splitting)\n      var aConsumedBy = a;\n      var bConsumedBy = b;\n      while (aConsumedBy.consumedBy) {\n        aConsumedBy = aConsumedBy.consumedBy;\n      }while (bConsumedBy.consumedBy) {\n        bConsumedBy = bConsumedBy.consumedBy;\n      } // for segment angle comparisons\n      var aCmpBLeft = void 0,\n          aCmpBRight = void 0,\n          bCmpALeft = void 0,\n          bCmpARight = void 0;\n\n      if (aConsumedBy === bConsumedBy) {\n        // are they identical?\n        if (a === b) return 0;\n\n        // colinear segments with matching left-endpoints, fall back\n        // on creation order of left sweep events as a tie-breaker\n        var aId = a.leftSE.id;\n        var bId = b.leftSE.id;\n        if (aId < bId) return -1;\n        if (aId > bId) return 1;\n      } else if (\n      // are a and b colinear?\n      (aCmpBLeft = a.comparePoint(b.leftSE.point)) === 0 && (aCmpBRight = a.comparePoint(b.rightSE.point)) === 0 && (bCmpALeft = b.comparePoint(a.leftSE.point)) === 0 && (bCmpARight = b.comparePoint(a.rightSE.point)) === 0) {\n        // they're colinear\n\n        // colinear segments with non-matching left-endpoints, consider\n        // the more-left endpoint to be earlier\n        var cmpLX = (0, _flp.cmp)(alx, blx);\n        if (cmpLX !== 0) return cmpLX;\n\n        // NOTE: we do not use segment length to break a tie here, because\n        //       when segments are split their length changes\n\n        // colinear segments with matching left-endpoints, fall back\n        // on creation order of left sweep events as a tie-breaker\n        var _aId = a.leftSE.id;\n        var _bId = b.leftSE.id;\n        if (_aId < _bId) return -1;\n        if (_aId > _bId) return 1;\n      } else {\n        // not colinear\n\n        // if the our left endpoints are not in the same vertical line,\n        // consider a vertical line at the rightmore of the two left endpoints,\n        // consider the segment that intersects lower with that line to be earlier\n        var _cmpLX = (0, _flp.cmp)(alx, blx);\n        if (_cmpLX < 0) {\n          if (aCmpBLeft === 1) return -1;\n          if (aCmpBLeft === -1) return 1;\n        }\n        if (_cmpLX > 0) {\n          if (bCmpALeft === undefined) bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft;\n        }\n\n        // one or both of the left endpoints intersect with the other segment,\n        // so consider the segment that angles more downward to be earlier\n        var cmpLY = (0, _flp.cmp)(aly, bly);\n        if (cmpLY === 0) {\n          // special case verticals due to rounding errors\n          // part of https://github.com/mfogel/polygon-clipping/issues/29\n          var aVert = a.isVertical();\n          if (aVert !== b.isVertical()) return aVert ? 1 : -1;else {\n            // sometimes, because one segment is longer than the other,\n            // one of these comparisons will return 0 and the other won't\n            if (aCmpBRight === undefined) aCmpBRight = a.comparePoint(b.rightSE.point);\n            if (aCmpBRight > 0) return -1;\n            if (aCmpBRight < 0) return 1;\n            if (bCmpARight === undefined) bCmpARight = b.comparePoint(a.rightSE.point);\n            if (bCmpARight > 0) return 1;\n            if (bCmpARight < 0) return -1;\n          }\n        } else {\n          // left endpoints are in the same vertical line but don't overlap exactly,\n          // lower means ealier\n          return cmpLY;\n        }\n      }\n\n      throw new Error('Segment comparison of ' + ('[' + a.leftSE.point.x + ', ' + a.leftSE.point.y + '] -> [' + a.rightSE.point.x + ', ' + a.rightSE.point.y + '] ') + 'against ' + ('[' + b.leftSE.point.x + ', ' + b.leftSE.point.y + '] -> [' + b.rightSE.point.x + ', ' + b.rightSE.point.y + '] ') + 'failed. Please submit a bug report.');\n    }\n\n    /* Warning: a reference to ringsIn input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, ringsIn) {\n    _classCallCheck(this, Segment);\n\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.ringsIn = ringsIn;\n    this._cache = {};\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: 'replaceRightSE',\n\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: 'bbox',\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n        ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\n      };\n    }\n\n    /* A vector from the left point to the right */\n\n  }, {\n    key: 'vector',\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: 'isVertical',\n    value: function isVertical() {\n      return (0, _flp.cmp)(this.leftSE.point.x, this.rightSE.point.x) === 0;\n    }\n  }, {\n    key: 'isAnEndpoint',\n    value: function isAnEndpoint(point) {\n      return (0, _flp.cmpPoints)(point, this.leftSE.point) === 0 || (0, _flp.cmpPoints)(point, this.rightSE.point) === 0;\n    }\n\n    /* Compare this segment with a point. Return value indicates\n     *    1: point is below segment\n     *    0: point is colinear to segment\n     *   -1: point is above segment */\n\n  }, {\n    key: 'comparePoint',\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var v1 = this.vector();\n      var v2 = (0, _vector.perpendicular)(v1);\n      var interPt = (0, _vector.intersection)(this.leftSE.point, v1, point, v2);\n\n      // Trying to be as exact as possible here, hence not using flp comparisons\n      if (point.y < interPt.y) return -1;\n      if (point.y > interPt.y) return 1;\n      if (point.x > interPt.x) return -1;\n      if (point.x < interPt.x) return 1;\n      return 0;\n    }\n\n    /* Does the given point fall on this segment? Greedy comparison */\n\n  }, {\n    key: 'touches',\n    value: function touches(point) {\n      if (this.isAnEndpoint(point)) return true;\n      var v1 = this.vector();\n      var v2 = (0, _vector.perpendicular)(v1);\n      var interPt = (0, _vector.intersection)(this.leftSE.point, v1, point, v2);\n      return (0, _flp.cmpPoints)(point, interPt) === 0;\n    }\n\n    /**\n     * Given another segment, returns an array of intersection points\n     * between the two segments. The returned array can contain:\n     *  * zero points:  no intersection b/t segments\n     *  * one point:    segments intersect once\n     *  * two points:   segments overlap. Endpoints of overlap returned.\n     *                  Will be ordered as sweep line would encounter them.\n     */\n\n  }, {\n    key: 'getIntersections',\n    value: function getIntersections(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var bboxOverlap = (0, _bbox.getBboxOverlap)(this.bbox(), other.bbox());\n      if (bboxOverlap === null) return [];\n\n      // The general algorithim doesn't handle overlapping colinear segments.\n      // Overlapping colinear segments, if present, will have intersections\n      // of one pair of opposing corners of the bbox overlap. Thus we just\n      // manually check those coordinates.\n      //\n      // Note this also handles the cases of a collapsed bbox (just one point)\n      // and semi-collapsed bbox (a vertical or horizontal line) as well.\n      //\n      // In addition, in the case of a T-intersection, this ensures that the\n      // interseciton returned matches exactly an endpoint - no rounding error.\n      var intersections = [];\n      var bboxCorners = (0, _bbox.getUniqueCorners)(bboxOverlap);\n      for (var i = 0, iMax = bboxCorners.length; i < iMax; i++) {\n        var pt = bboxCorners[i];\n        if (this.touches(pt) && other.touches(pt)) intersections.push(pt);\n      }\n\n      if (intersections.length === 0) {\n        // general case of one intersection between non-overlapping segments\n        var _pt = (0, _vector.intersection)(this.leftSE.point, this.vector(), other.leftSE.point, other.vector());\n        if (_pt !== null && (0, _bbox.isInBbox)(bboxOverlap, _pt)) intersections.push(_pt);\n      }\n\n      return intersections;\n    }\n\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: 'split',\n    value: function split(points) {\n      // sort the points in sweep line order\n      points.sort(_flp.cmpPoints);\n\n      var prevSeg = this;\n      var prevPoint = null;\n\n      var newEvents = [];\n      for (var i = 0, iMax = points.length; i < iMax; i++) {\n        var point = points[i];\n        // skip repeated points\n        if (prevPoint && (0, _flp.cmpPoints)(prevPoint, point) === 0) continue;\n\n        var newLeftSE = new _sweepEvent2.default(point, true);\n        var newRightSE = new _sweepEvent2.default(point, false);\n        var oldRightSE = prevSeg.rightSE;\n        prevSeg.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n\n        prevSeg = new Segment(newLeftSE, oldRightSE, this.ringsIn.slice());\n        prevPoint = point;\n      }\n\n      return newEvents;\n    }\n\n    /* Consume another segment. We take their ringsIn under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: 'consume',\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      }\n\n      for (var i = 0, iMax = consumee.ringsIn.length; i < iMax; i++) {\n        consumer.ringsIn.push(consumee.ringsIn[i]);\n      }\n      consumee.ringsIn = null;\n      consumee.consumedBy = consumer;\n\n      // mark sweep events consumed as to maintain ordering in sweep event queue\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: 'prevInResult',\n    value: function prevInResult() {\n      var key = 'prevInResult';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_prevInResult',\n    value: function _prevInResult() {\n      if (!this.prev) return null;\n      if (this.prev.isInResult()) return this.prev;\n      return this.prev.prevInResult();\n    }\n  }, {\n    key: 'ringsBefore',\n    value: function ringsBefore() {\n      var key = 'ringsBefore';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_ringsBefore',\n    value: function _ringsBefore() {\n      if (!this.prev) return [];\n      return (this.prev.consumedBy || this.prev).ringsAfter();\n    }\n  }, {\n    key: 'ringsAfter',\n    value: function ringsAfter() {\n      var key = 'ringsAfter';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_ringsAfter',\n    value: function _ringsAfter() {\n      var rings = this.ringsBefore().slice(0);\n      for (var i = 0, iMax = this.ringsIn.length; i < iMax; i++) {\n        var ring = this.ringsIn[i];\n        var index = rings.indexOf(ring);\n        if (index === -1) rings.push(ring);else rings.splice(index, 1);\n      }\n      return rings;\n    }\n  }, {\n    key: 'multiPolysBefore',\n    value: function multiPolysBefore() {\n      var key = 'multiPolysBefore';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_multiPolysBefore',\n    value: function _multiPolysBefore() {\n      if (!this.prev) return [];\n      return (this.prev.consumedBy || this.prev).multiPolysAfter();\n    }\n  }, {\n    key: 'multiPolysAfter',\n    value: function multiPolysAfter() {\n      var key = 'multiPolysAfter';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_multiPolysAfter',\n    value: function _multiPolysAfter() {\n      // first calcualte our polysAfter\n      var polysAfter = [];\n      var polysExclude = [];\n      var ringsAfter = this.ringsAfter();\n      for (var i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n        var ring = ringsAfter[i];\n        var poly = ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (ring.isExterior) polysAfter.push(poly);else {\n          if (!(polysExclude.indexOf(poly) !== -1)) polysExclude.push(poly);\n          var index = polysAfter.indexOf(ring.poly);\n          if (index !== -1) polysAfter.splice(index, 1);\n        }\n      }\n      // now calculate our multiPolysAfter\n      var mps = [];\n      for (var _i = 0, _iMax = polysAfter.length; _i < _iMax; _i++) {\n        var mp = polysAfter[_i].multiPoly;\n        if (!(mps.indexOf(mp) !== -1)) mps.push(mp);\n      }\n      return mps;\n    }\n\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: 'isInResult',\n    value: function isInResult() {\n      var key = 'isInResult';\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\n      return this._cache[key];\n    }\n  }, {\n    key: '_isInResult',\n    value: function _isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n\n      var mpsBefore = this.multiPolysBefore();\n      var mpsAfter = this.multiPolysAfter();\n\n      switch (_operation2.default.type) {\n        case 'union':\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          var noBefores = mpsBefore.length === 0;\n          var noAfters = mpsAfter.length === 0;\n          return noBefores !== noAfters;\n\n        case 'intersection':\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          var least = void 0;\n          var most = void 0;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          return most === _operation2.default.numMultiPolys && least < most;\n\n        case 'xor':\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          return diff % 2 === 1;\n\n        case 'difference':\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          var isJustSubject = function isJustSubject(mps) {\n            return mps.length === 1 && mps[0].isSubject;\n          };\n          return isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n\n        default:\n          throw new Error('Unrecognized operation type found ' + _operation2.default.type);\n      }\n    }\n  }], [{\n    key: 'fromRing',\n    value: function fromRing(point1, point2, ring) {\n      var leftSE = void 0,\n          rightSE = void 0;\n      var ptCmp = (0, _flp.cmpPoints)(point1, point2);\n      if (ptCmp < 0) {\n        leftSE = new _sweepEvent2.default(point1, true);\n        rightSE = new _sweepEvent2.default(point2, false);\n      } else if (ptCmp > 0) {\n        leftSE = new _sweepEvent2.default(point2, true);\n        rightSE = new _sweepEvent2.default(point1, false);\n      } else {\n        throw new Error('Tried to create degenerate segment at [' + point1.x + ', ' + point2.y + ']');\n      }\n      return new Segment(leftSE, rightSE, [ring]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nexports.default = Segment;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://polygon-clipping/./src/segment.js?");

/***/ }),

/***/ "./src/sweep-event.js":
/*!****************************!*\
  !*** ./src/sweep-event.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _flp = __webpack_require__(/*! ./flp */ \"./src/flp.js\");\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Give sweep events unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nvar sweepEventId = 0;\n\nvar SweepEvent = function () {\n  _createClass(SweepEvent, null, [{\n    key: 'compare',\n    value: function compare(a, b) {\n\n      // if the events are already linked, then we know the points are equal\n      if (a.point !== b.point) {\n\n        // favor event with a point that the sweep line hits first\n        var cmpX = (0, _flp.cmp)(a.point.x, b.point.x);\n        if (cmpX !== 0) return cmpX;\n\n        var cmpY = (0, _flp.cmp)(a.point.y, b.point.y);\n        if (cmpY !== 0) return cmpY;\n\n        // Points are equal, so go ahead and link these events.\n        a.link(b);\n      }\n\n      // favor right events over left\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n      // are they identical?\n      if (a === b) return 0;\n\n      // The calcuations of relative segment angle below can give different\n      // results after segment splitting due to rounding errors.\n      // To maintain sweep event queue ordering, we thus skip these calculations\n      // if we already know the segements to be colinear (one of the requirements\n      // of the 'consumedBy' relationship).\n      var aConsumedBy = a;\n      var bConsumedBy = b;\n      while (aConsumedBy.consumedBy) {\n        aConsumedBy = aConsumedBy.consumedBy;\n      }while (bConsumedBy.consumedBy) {\n        bConsumedBy = bConsumedBy.consumedBy;\n      }if (aConsumedBy !== bConsumedBy) {\n\n        // favor vertical segments for left events, and non-vertical for right\n        // https://github.com/mfogel/polygon-clipping/issues/29\n        var aVert = a.segment.isVertical();\n        var bVert = b.segment.isVertical();\n        if (aVert && !bVert) return a.isLeft ? 1 : -1;\n        if (!aVert && bVert) return a.isLeft ? -1 : 1;\n\n        // Favor events where the line segment is lower.\n        // Sometimes, because one segment is longer than the other,\n        // one of these comparisons will return 0 and the other won't.\n        var pointSegCmp = a.segment.comparePoint(b.otherSE.point);\n        if (pointSegCmp === 1) return -1;\n        if (pointSegCmp === -1) return 1;\n        var otherPointSegCmp = b.segment.comparePoint(a.otherSE.point);\n        if (otherPointSegCmp !== 0) return otherPointSegCmp;\n\n        // NOTE:  We don't sort on segment length because that changes\n        //        as segments are divided.\n      }\n\n      // as a tie-breaker, favor lower creation id\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1;\n\n      throw new Error('SweepEvent comparison failed at [' + a.point.x + ', ' + a.point.y + ']');\n    }\n\n    // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    this.id = ++sweepEventId;\n    // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: 'link',\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n      var numOriginalEvents = this.point.events.length;\n      var otherEvents = other.point.events;\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n        for (var j = 0, jMax = numOriginalEvents; j < jMax; j++) {\n          if (this.point.events[j].otherSE.point === evt.otherSE.point) {\n            this.point.events[j].segment.consume(evt.segment);\n          }\n        }\n      }\n    }\n  }, {\n    key: 'getAvailableLinkedEvents',\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n      return events;\n    }\n\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: 'getLeftmostComparator',\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: (0, _vector.sineOfAngle)(_this.point, baseEvent.point, nextEvent.point),\n          cosine: (0, _vector.cosineOfAngle)(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine;\n\n        var cmpZeroASine = (0, _flp.cmp)(asine, 0);\n        var cmpZeroBSine = (0, _flp.cmp)(bsine, 0);\n\n        if (cmpZeroASine >= 0 && cmpZeroBSine >= 0) return (0, _flp.cmp)(bcosine, acosine);\n        if (cmpZeroASine < 0 && cmpZeroBSine < 0) return (0, _flp.cmp)(acosine, bcosine);\n        return (0, _flp.cmp)(bsine, asine);\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\nexports.default = SweepEvent;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://polygon-clipping/./src/sweep-event.js?");

/***/ }),

/***/ "./src/sweep-line.js":
/*!***************************!*\
  !*** ./src/sweep-line.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _splaytree = __webpack_require__(/*! splaytree */ \"./node_modules/splaytree/index.js\");\n\nvar _splaytree2 = _interopRequireDefault(_splaytree);\n\nvar _segment = __webpack_require__(/*! ./segment */ \"./src/segment.js\");\n\nvar _segment2 = _interopRequireDefault(_segment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _segment2.default.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new _splaytree2.default(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: 'process',\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = [];\n\n      // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n      if (event.consumedBy) {\n        if (!event.isLeft) this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n\n      if (!node) throw new Error('Unable to find segment #' + segment.leftSE.id + ' ' + ('[' + segment.leftSE.point.x + ', ' + segment.leftSE.point.y + '] -> ') + ('[' + segment.rightSE.point.x + ', ' + segment.rightSE.point.y + '] ') + 'in SweepLine tree. Please submit a bug report.');\n\n      var prevNode = this.tree.prev(node);\n      var prevSeg = prevNode ? prevNode.key : null;\n\n      var nextNode = this.tree.next(node);\n      var nextSeg = nextNode ? nextNode.key : null;\n\n      if (event.isLeft) {\n        var mySplitters = [];\n\n        // Check for intersections against the previous segment in the sweep line\n        if (prevSeg) {\n          var prevInters = prevSeg.getIntersections(segment);\n          if (prevInters.length > 0) {\n            var newEventsFromSplit = this._possibleSplit(prevSeg, prevInters);\n            for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n            for (var _i = 0, _iMax = prevInters.length; _i < _iMax; _i++) {\n              var pt = prevInters[_i];\n              if (!segment.isAnEndpoint(pt)) mySplitters.push(pt);\n            }\n          }\n        }\n\n        // Check for intersections against the next segment in the sweep line\n        if (nextSeg) {\n          var nextInters = nextSeg.getIntersections(segment);\n          if (nextInters.length > 0) {\n            var _newEventsFromSplit = this._possibleSplit(nextSeg, nextInters);\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit[_i2]);\n            }\n            for (var _i3 = 0, _iMax3 = nextInters.length; _i3 < _iMax3; _i3++) {\n              var _pt = nextInters[_i3];\n              if (!segment.isAnEndpoint(_pt)) mySplitters.push(_pt);\n            }\n          }\n        }\n\n        // did we get some intersections? split ourselves if need be\n        if (newEvents.length > 0 || mySplitters.length > 0) {\n\n          // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n          this.tree.remove(segment);\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          if (mySplitters.length > 0) {\n            var _newEventsFromSplit2 = segment.split(mySplitters);\n            for (var _i4 = 0, _iMax4 = _newEventsFromSplit2.length; _i4 < _iMax4; _i4++) {\n              newEvents.push(_newEventsFromSplit2[_i4]);\n            }\n          }\n\n          // Make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers - re-do the current event.\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inters = prevSeg.getIntersections(nextSeg);\n          if (inters.length > 0) {\n            var _newEventsFromSplit3 = this._possibleSplit(prevSeg, inters);\n            for (var _i5 = 0, _iMax5 = _newEventsFromSplit3.length; _i5 < _iMax5; _i5++) {\n              newEvents.push(_newEventsFromSplit3[_i5]);\n            }\n            _newEventsFromSplit3 = this._possibleSplit(nextSeg, inters);\n            for (var _i6 = 0, _iMax6 = _newEventsFromSplit3.length; _i6 < _iMax6; _i6++) {\n              newEvents.push(_newEventsFromSplit3[_i6]);\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n  }, {\n    key: '_possibleSplit',\n    value: function _possibleSplit(segment, intersections) {\n      var splitters = [];\n      for (var i = 0, iMax = intersections.length; i < iMax; i++) {\n        var pt = intersections[i];\n        if (!segment.isAnEndpoint(pt)) splitters.push(pt);\n      }\n      var newEvents = [];\n      if (splitters.length > 0) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(segment);\n        var rightSE = segment.rightSE;\n        this.queue.remove(rightSE);\n        newEvents = segment.split(splitters);\n        newEvents.push(rightSE);\n        this.tree.insert(segment);\n      }\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nexports.default = SweepLine;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://polygon-clipping/./src/sweep-line.js?");

/***/ }),

/***/ "./src/vector.js":
/*!***********************!*\
  !*** ./src/vector.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.perpendicular = exports.intersection = exports.verticalIntersection = exports.horizontalIntersection = exports.cosineOfAngle = exports.sineOfAngle = exports.length = exports.compareVectorAngles = exports.dotProduct = exports.crossProduct = undefined;\n\nvar _flp = __webpack_require__(/*! ./flp */ \"./src/flp.js\");\n\n/* Cross Product of two vectors with first point at origin */\nvar crossProduct = exports.crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n\n/* Dot Product of two vectors with first point at origin */\nvar dotProduct = exports.dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n\n/* Comparator for two vectors with same starting point */\nvar compareVectorAngles = exports.compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y };\n  var v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y };\n  var kross = crossProduct(v1, v2);\n  return (0, _flp.cmp)(kross, 0);\n};\n\nvar length = exports.length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nvar sineOfAngle = exports.sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nvar cosineOfAngle = exports.cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nvar horizontalIntersection = exports.horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return { x: pt.x + v.x / v.y * (y - pt.y), y: y };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nvar verticalIntersection = exports.verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return { x: x, y: pt.y + v.y / v.x * (x - pt.x) };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nvar intersection = exports.intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n\n  var ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return { x: x, y: y };\n};\n\n/* Given a vector, return one that is perpendicular */\nvar perpendicular = exports.perpendicular = function perpendicular(v) {\n  return { x: -v.y, y: v.x };\n};\n\n//# sourceURL=webpack://polygon-clipping/./src/vector.js?");

/***/ })

/******/ });
});